{"version":3,"file":"static/js/58755.c830cd5b.chunk.js","mappings":"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","sources":["../node_modules/timezone-groups/dist/groupByOffset/index.mjs","../node_modules/timezone-groups/dist/utils/region.mjs","../node_modules/timezone-groups/dist/utils/time-zones.mjs"],"sourcesContent":["import { timeZones } from '../utils/time-zones.mjs';\nimport { extractRegion, global } from '../utils/region.mjs';\nimport '../chunks/index-p4VH55K1.mjs';\n\nconst now = new Date();\nconst startDate = now.toISOString();\nconst daysInYear = 365;\nconst groupDateRange = daysInYear;\nconst defaultGroupingOptions = {\n    groupDateRange,\n    startDate,\n};\n\nconst _getDates = (startDate, numberDays, dateEngine) => {\n    const dateArray = [];\n    let date = dateEngine.create(startDate);\n    for (let i = 0; i <= numberDays; i++) {\n        date = dateEngine.increase(date);\n        dateArray.push(dateEngine.formatToIsoDateString(date));\n    }\n    return dateArray;\n};\nconst generateTimeZoneMetadata = (timeZoneItems, startDate, numberDays, dateEngine) => {\n    const processedDates = new Map();\n    const theDates = _getDates(startDate, numberDays, dateEngine);\n    return timeZoneItems.map((tzItem) => {\n        const { label } = tzItem;\n        const continent = extractRegion(label);\n        const dates = theDates.map((date) => {\n            const key = `${date}-${label}`;\n            let utc = processedDates.get(key);\n            if (utc) {\n                return utc;\n            }\n            utc = dateEngine.isoToTimeZone(date, label);\n            processedDates.set(key, utc);\n            return utc;\n        });\n        return {\n            ...tzItem,\n            continent,\n            isRegularContinent: continent !== global,\n            dates,\n        };\n    });\n};\nconst compareDateArrs = (array1, array2, dateEngine) => array1.length === array2.length &&\n    array1.every((value, index) => dateEngine.same(value, array2[index]));\nconst getGroupLabelTimeZoneIndices = (rawTZs, max = 5) => {\n    const shrinkedTzs = rawTZs.filter(({ label }) => extractRegion(label) !== global);\n    if (shrinkedTzs.length === 0) {\n        return [0];\n    }\n    const validLabels = shrinkedTzs.map((tz) => rawTZs.indexOf(tz));\n    return equallyDistributedSampling(validLabels, max);\n};\nfunction equallyDistributedSampling(items, maxItems = 5) {\n    const totalItems = items.length;\n    if (totalItems <= maxItems) {\n        return items;\n    }\n    const numberItemsToSelect = Math.min(totalItems - 2, maxItems - 2);\n    const stepSize = (totalItems - 1) / (numberItemsToSelect + 1);\n    return [\n        items[0],\n        ...Array.from({ length: numberItemsToSelect }, (_, i) => items[Math.round((i + 1) * stepSize)]),\n        items[totalItems - 1],\n    ];\n}\n\nasync function groupByOffset(options) {\n    const { groupDateRange, startDate, dateEngine } = {\n        ...defaultGroupingOptions,\n        ...options,\n    };\n    const grouping = [];\n    if (!dateEngine) {\n        throw new Error('dateEngine is required');\n    }\n    const timeZoneItems = timeZones.map((tz) => ({ label: tz }));\n    const timeZoneMetadata = generateTimeZoneMetadata(timeZoneItems, startDate, groupDateRange, dateEngine);\n    // We traverse the mappedDB and see if we find matches by comparing each set\n    // of transformed date for that specific TZ.\n    for (const tzMetadatumI of timeZoneMetadata) {\n        const { label, continent, dates } = tzMetadatumI;\n        if (tzMetadatumI.visited) {\n            continue;\n        }\n        tzMetadatumI.visited = true;\n        const newGroup = {\n            labelIdx: [],\n            tzs: [{ label }],\n        };\n        for (const tzMetadatumJ of timeZoneMetadata.filter((_) => !_.visited)) {\n            const { label: labelJ, continent: continentJ, isRegularContinent: isRegularContinentJ, dates: datesJ, } = tzMetadatumJ;\n            // We define a matching TZ by:\n            // 1) if both continents match (avoid grouping Antarctica with anything else)\n            // 2) if the transformed dates match in both TZs\n            if ((continent === continentJ || !isRegularContinentJ) &&\n                compareDateArrs(dates, datesJ, dateEngine)) {\n                const tzItem = { label: labelJ };\n                newGroup.tzs.push(tzItem);\n                tzMetadatumJ.visited = true;\n            }\n        }\n        grouping.push(newGroup);\n    }\n    // Now that we have a group, we want an easy way to find a fitting label for the group\n    // which is defined as the list of the most-common 7 cities, shown in alphabetical order\n    return grouping\n        .map((group) => {\n        group.tzs = group.tzs.sort((a, b) => a.label.localeCompare(b.label));\n        return {\n            labelTzIdx: getGroupLabelTimeZoneIndices(group.tzs, 7),\n            tzs: group.tzs.map((_) => _.label),\n        };\n    })\n        .sort((a, b) => b.tzs.length - a.tzs.length);\n}\n\nexport { groupByOffset };\n","import { g as getCountryForTimezone, a as getTimezone } from '../chunks/index-p4VH55K1.mjs';\n\nconst global = 'Global';\n/**\n * Check if a timezone is global (no country associated).\n */\nfunction isGlobal(tz) {\n    return getTimezone(tz).countries.length === 0;\n}\n/**\n * Extract the region from a timezone.\n */\nfunction extractRegion(tz) {\n    if (isGlobal(tz)) {\n        return global;\n    }\n    const separatorIndex = tz.indexOf('/');\n    return separatorIndex === -1 ? tz : tz.slice(0, separatorIndex);\n}\n/**\n * Gets the country code for a timezone.\n */\nfunction getCountry(timeZone) {\n    return getCountryForTimezone(timeZone)?.id ?? timeZone;\n}\n\nexport { extractRegion, getCountry, global };\n","import { b as getAllTimezones, a as getTimezone } from '../chunks/index-p4VH55K1.mjs';\n\n/**\n * Handling these deprecated timezones locally until `countries-and-timezones` is updated with the latest IANA time zone db\n *\n * @see https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\n * @see https://github.com/eggert/tz/commit/782d082623aaa130178d944bdbfbb563d2e1adfa\n * @see https://github.com/eggert/tz/commit/a0b09c0230089252acf2eb0f1ba922e99f7f4a03\n */\nconst deprecatedTimeZonesToAlias = {\n    /* eslint-disable @typescript-eslint/naming-convention */\n    CET: 'Europe/Brussels',\n    CST6CDT: 'America/Chicago',\n    EET: 'Europe/Athens',\n    EST: 'America/Panama',\n    EST5EDT: 'America/New_York',\n    HST: 'Pacific/Honolulu',\n    MET: 'Europe/Brussels',\n    MST: 'America/Phoenix',\n    MST7MDT: 'America/Denver',\n    PST8PDT: 'America/Los_Angeles',\n    WET: 'Europe/Lisbon',\n    /* eslint-enable @typescript-eslint/naming-convention */\n};\n/**\n * List of all supported, canonical, timezones.\n */\nconst timeZones = (() => {\n    const futureDeprecatedTimeZones = Object.keys(deprecatedTimeZonesToAlias);\n    return Object.keys(getAllTimezones()).filter((tz) => !futureDeprecatedTimeZones.includes(tz));\n})();\n/**\n * Normalize an IANA timezone name to its canonical equivalent.\n */\nfunction normalize(tz) {\n    const localDeprecatedTimeZone = deprecatedTimeZonesToAlias[tz];\n    if (localDeprecatedTimeZone) {\n        return localDeprecatedTimeZone;\n    }\n    const tzData = getTimezone(tz);\n    return tzData?.aliasOf ?? tz;\n}\n\nexport { normalize, timeZones };\n"],"names":["defaultGroupingOptions","groupDateRange","startDate","Date","toISOString","compareDateArrs","array1","array2","dateEngine","length","every","value","index","same","getGroupLabelTimeZoneIndices","rawTZs","max","arguments","undefined","shrinkedTzs","filter","_ref","label","extractRegion","global","items","maxItems","totalItems","numberItemsToSelect","Math","min","stepSize","Array","from","_","i","round","equallyDistributedSampling","map","tz","indexOf","async","groupByOffset","options","_objectSpread","grouping","Error","timeZoneMetadata","generateTimeZoneMetadata","timeZoneItems","numberDays","processedDates","Map","theDates","_getDates","dateArray","date","create","increase","push","formatToIsoDateString","tzItem","continent","dates","key","concat","utc","get","isoToTimeZone","set","isRegularContinent","timeZones","tzMetadatumI","visited","newGroup","labelIdx","tzs","tzMetadatumJ","labelJ","continentJ","isRegularContinentJ","datesJ","group","sort","a","b","localeCompare","labelTzIdx","getTimezone","countries","isGlobal","separatorIndex","slice","getCountry","timeZone","_getCountryForTimezon","_getCountryForTimezon2","getCountryForTimezone","id","deprecatedTimeZonesToAlias","CET","CST6CDT","EET","EST","EST5EDT","HST","MET","MST","MST7MDT","PST8PDT","WET","futureDeprecatedTimeZones","Object","keys","getAllTimezones","includes","normalize","_tzData$aliasOf","localDeprecatedTimeZone","tzData","aliasOf"],"sourceRoot":""}