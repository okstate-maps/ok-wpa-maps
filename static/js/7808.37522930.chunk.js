"use strict";(self.webpackChunkok_wpa_maps=self.webpackChunkok_wpa_maps||[]).push([[7808],{46888:(e,t,r)=>{var i;r.d(t,{B:()=>i}),function(e){e[e.Texture=0]="Texture",e[e.RenderBuffer=1]="RenderBuffer"}(i||(i={}))},57808:(e,t,r)=>{r.d(t,{x:()=>d});var i=r(10064),s=(r(93169),r(16889)),o=r(37825),a=r(83826),n=r(8548),l=r(46888),c=r(52311);class _ extends c.X{constructor(e,t){switch(super(),this.context=e,Object.assign(this,t),this.internalFormat){case n.lP.R16F:case n.lP.R16I:case n.lP.R16UI:case n.lP.R32F:case n.lP.R32I:case n.lP.R32UI:case n.lP.R8_SNORM:case n.lP.R8:case n.lP.R8I:case n.lP.R8UI:this.pixelFormat=n.VI.RED}}static validate(e,t){return new _(e,t)}}let d=class{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;if(this.type=l.B.Texture,this._glName=null,this._samplingModeDirty=!1,this._wrapModeDirty=!1,this._wasImmutablyAllocated=!1,"context"in e)this._descriptor=e,r=t;else{const r=_.validate(e,t);if(!r)throw new i.Z("Texture descriptor invalid");this._descriptor=r}if(this._descriptor.context.type!==a.zO.WEBGL2&&(this._descriptor.isImmutable&&(this._descriptor.isImmutable=!1),T(this._descriptor.target)))throw new i.Z("3D and array textures are not supported in WebGL1");this._descriptor.target===n.No.TEXTURE_CUBE_MAP?this._setDataCubeMap(r):this.setData(r)}get glName(){return this._glName}get descriptor(){return this._descriptor}get gpuMemoryUsage(){return g.delete(this),(0,c.G)(this._descriptor)}get isDirty(){return this._samplingModeDirty||this._wrapModeDirty}dispose(){this._glName&&this._descriptor.context.instanceCounter.decrement(n._g.Texture,this),this._descriptor.context.gl&&this._glName&&(this._descriptor.context.unbindTexture(this),this._descriptor.context.gl.deleteTexture(this._glName),this._glName=null)}release(){this.dispose()}resize(e,t){const r=this._descriptor;if(r.width!==e||r.height!==t){if(this._wasImmutablyAllocated)throw new i.Z("Immutable textures can't be resized!");r.width=e,r.height=t,this._descriptor.target===n.No.TEXTURE_CUBE_MAP?this._setDataCubeMap(null):this.setData(null)}}_setDataCubeMap(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;for(let t=n.No.TEXTURE_CUBE_MAP_POSITIVE_X;t<=n.No.TEXTURE_CUBE_MAP_NEGATIVE_Z;t++)this._setData(e,t)}setData(e){this._setData(e)}_setData(e,t){var r,s;if(null===(r=this._descriptor.context)||void 0===r||!r.gl)return;const a=this._descriptor.context.gl;(0,o.zu)(a),this._glName||(this._glName=a.createTexture(),this._glName&&this._descriptor.context.instanceCounter.increment(n._g.Texture,this)),void 0===e&&(e=null);const l=this._descriptor,c=null!==t&&void 0!==t?t:l.target,_=T(c);null===e&&(l.width=l.width||4,l.height=l.height||4,_&&(l.depth=null!==(s=l.depth)&&void 0!==s?s:1));const g=this._descriptor.context.bindTexture(this,d.TEXTURE_UNIT_FOR_UPDATES);this._descriptor.context.setActiveTexture(d.TEXTURE_UNIT_FOR_UPDATES),h(this._descriptor.context,l),this._configurePixelStorage(),(0,o.zu)(a);const I=this._deriveInternalFormat();if(E(e)){let t="width"in e?e.width:e.codedWidth,r="height"in e?e.height:e.codedHeight;const i=1;e instanceof HTMLVideoElement&&(t=e.videoWidth,r=e.videoHeight),l.width&&l.height,_&&l.depth,l.isImmutable&&!this._wasImmutablyAllocated&&this._texStorage(c,I,l.hasMipmap,t,r,i),this._texImage(c,0,I,t,r,i,e),(0,o.zu)(a),l.hasMipmap&&this.generateMipmap(),l.width||(l.width=t),l.height||(l.height=r),_&&!l.depth&&(l.depth=i)}else{const{width:t,height:r,depth:s}=l;if(null==t||null==r)throw new i.Z("Width and height must be specified!");if(_&&null==s)throw new i.Z("Depth must be specified!");if(l.isImmutable&&!this._wasImmutablyAllocated&&this._texStorage(c,I,l.hasMipmap,t,r,s),m(e)){const o=e.levels,_=R(c,t,r,s),d=Math.min(_-1,o.length-1);null!=this._descriptor.context.gl2?a.texParameteri(l.target,this._descriptor.context.gl2.TEXTURE_MAX_LEVEL,d):l.hasMipmap=l.hasMipmap&&_===o.length;const h=I;if(!(h in n.q_))throw new i.Z("Attempting to use compressed data with an uncompressed format!");this._forEachMipmapLevel(((e,t,r,i)=>{const s=o[Math.min(e,o.length-1)];this._compressedTexImage(c,e,h,t,r,i,s)}),d)}else this._texImage(c,0,I,t,r,s,e),(0,o.zu)(a),l.hasMipmap&&this.generateMipmap()}u(a,this._descriptor),p(a,this._descriptor),function(e,t){var r;const i=e.capabilities.textureFilterAnisotropic;if(!i)return;e.gl.texParameterf(t.target,i.TEXTURE_MAX_ANISOTROPY,null!==(r=t.maxAnisotropy)&&void 0!==r?r:1)}(this._descriptor.context,this._descriptor),(0,o.zu)(a),this._descriptor.context.bindTexture(g,d.TEXTURE_UNIT_FOR_UPDATES)}updateData(e,t,r,s,o,a){let n=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;a||console.error("An attempt to use uninitialized data!"),this._glName||console.error("An attempt to update uninitialized texture!");const l=this._descriptor.context.gl,c=this._descriptor.context.gl2,_=this._descriptor,h=this._deriveInternalFormat(),{pixelFormat:u,dataType:p,target:T,isImmutable:R}=_;if(R&&!this._wasImmutablyAllocated)throw new i.Z("Cannot update immutable texture before allocation!");const g=this._descriptor.context.bindTexture(this,d.TEXTURE_UNIT_FOR_UPDATES,!0);if((t<0||r<0||s>_.width||o>_.height||t+s>_.width||r+o>_.height)&&console.error("An attempt to update out of bounds of the texture!"),this._configurePixelStorage(),n){if(!c)return void console.error("Webgl2 must be enabled to use dataRowOffset!");l.pixelStorei(c.UNPACK_SKIP_ROWS,n)}if(E(a)?c?c.texSubImage2D(T,e,t,r,s,o,u,p,a):l.texSubImage2D(T,e,t,r,u,p,a):m(a)?l.compressedTexSubImage2D(T,e,t,r,s,o,h,a.levels[e]):l.texSubImage2D(T,e,t,r,s,o,u,p,a),n){if(!c)return void console.error("Webgl2 must be enabled to use dataRowOffset!");l.pixelStorei(c.UNPACK_SKIP_ROWS,0)}this._descriptor.context.bindTexture(g,d.TEXTURE_UNIT_FOR_UPDATES)}updateData3D(e,t,r,s,o,a,n,l){l||console.error("An attempt to use uninitialized data!"),this._glName||console.error("An attempt to update uninitialized texture!");const c=this._descriptor.context.gl2;if(null==c)throw new i.Z("3D textures are not supported in WebGL1");const _=this._descriptor,h=this._deriveInternalFormat(),{pixelFormat:u,dataType:p,isImmutable:E,target:R}=_;if(E&&!this._wasImmutablyAllocated)throw new i.Z("Cannot update immutable texture before allocation!");T(R)||console.warn("Attempting to set 3D texture data on a non-3D texture");const g=this._descriptor.context.bindTexture(this,d.TEXTURE_UNIT_FOR_UPDATES);if(this._descriptor.context.setActiveTexture(d.TEXTURE_UNIT_FOR_UPDATES),(t<0||r<0||s<0||o>_.width||a>_.height||n>_.depth||t+o>_.width||r+a>_.height||s+n>_.depth)&&console.error("An attempt to update out of bounds of the texture!"),this._configurePixelStorage(),m(l))l=l.levels[e],c.compressedTexSubImage3D(R,e,t,r,s,o,a,n,h,l);else{const i=l;c.texSubImage3D(R,e,t,r,s,o,a,n,u,p,i)}this._descriptor.context.bindTexture(g,d.TEXTURE_UNIT_FOR_UPDATES)}generateMipmap(){const e=this._descriptor;if(!e.hasMipmap){if(this._wasImmutablyAllocated)throw new i.Z("Cannot add mipmaps to immutable texture after allocation");e.hasMipmap=!0,this._samplingModeDirty=!0,h(this._descriptor.context,e)}e.samplingMode===n.cw.LINEAR?(this._samplingModeDirty=!0,e.samplingMode=n.cw.LINEAR_MIPMAP_NEAREST):e.samplingMode===n.cw.NEAREST&&(this._samplingModeDirty=!0,e.samplingMode=n.cw.NEAREST_MIPMAP_NEAREST);const t=this._descriptor.context.bindTexture(this,d.TEXTURE_UNIT_FOR_UPDATES);this._descriptor.context.setActiveTexture(d.TEXTURE_UNIT_FOR_UPDATES),this._descriptor.context.gl.generateMipmap(e.target),this._descriptor.context.bindTexture(t,d.TEXTURE_UNIT_FOR_UPDATES)}setSamplingMode(e){e!==this._descriptor.samplingMode&&(this._descriptor.samplingMode=e,this._samplingModeDirty=!0)}setWrapMode(e){e!==this._descriptor.wrapMode&&(this._descriptor.wrapMode=e,h(this._descriptor.context,this._descriptor),this._wrapModeDirty=!0)}applyChanges(){const e=this._descriptor.context.gl,t=this._descriptor;this._samplingModeDirty&&(u(e,t),this._samplingModeDirty=!1),this._wrapModeDirty&&(p(e,t),this._wrapModeDirty=!1)}_deriveInternalFormat(){if(this._descriptor.context.type===a.zO.WEBGL1)return this._descriptor.internalFormat=this._descriptor.pixelFormat;if(null!=this._descriptor.internalFormat)return this._descriptor.internalFormat===n.VI.DEPTH_STENCIL&&(this._descriptor.internalFormat=n.VI.DEPTH24_STENCIL8),this._descriptor.internalFormat;switch(this._descriptor.dataType){case n.Br.FLOAT:switch(this._descriptor.pixelFormat){case n.VI.RGBA:return this._descriptor.internalFormat=n.lP.RGBA32F;case n.VI.RGB:return this._descriptor.internalFormat=n.lP.RGB32F;default:throw new i.Z("Unable to derive format")}case n.Br.UNSIGNED_BYTE:switch(this._descriptor.pixelFormat){case n.VI.RGBA:return this._descriptor.internalFormat=n.lP.RGBA8;case n.VI.RGB:return this._descriptor.internalFormat=n.lP.RGB8}}return this._descriptor.internalFormat=this._descriptor.pixelFormat===n.VI.DEPTH_STENCIL?n.VI.DEPTH24_STENCIL8:this._descriptor.pixelFormat}_configurePixelStorage(){const e=this._descriptor.context.gl,{unpackAlignment:t,flipped:r,preMultiplyAlpha:i}=this._descriptor;e.pixelStorei(e.UNPACK_ALIGNMENT,t),e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,r?1:0),e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL,i?1:0)}_texStorage(e,t,r,s,o,a){const l=this._descriptor.context.gl2;if(null==l)throw new i.Z("Immutable textures are not supported in WebGL1");if(!(t in n.lP))throw new i.Z("Immutable textures must have a sized internal format");if(!this._descriptor.isImmutable)return;const c=r?R(e,s,o,a):1;if(T(e)){if(null==a)throw new i.Z("Missing depth dimension for 3D texture upload");l.texStorage3D(e,c,t,s,o,a)}else l.texStorage2D(e,c,t,s,o);this._wasImmutablyAllocated=!0}_texImage(e,t,r,s,o,n,l){const c=this._descriptor.context.gl,_=T(e),{isImmutable:d,pixelFormat:h,dataType:u}=this._descriptor,p=this._descriptor.context.type===a.zO.WEBGL2,m=p?c:null;if(p||!E(l))if(d){if(null!=l){const r=l;if(_){if(null==n)throw new i.Z("Missing depth dimension for 3D texture upload");m.texSubImage3D(e,t,0,0,0,s,o,n,h,u,r)}else c.texSubImage2D(e,t,0,0,s,o,h,u,r)}}else{const a=l;if(_){if(null==n)throw new i.Z("Missing depth dimension for 3D texture upload");m.texImage3D(e,t,r,s,o,n,0,h,u,a)}else c.texImage2D(e,t,r,s,o,0,h,u,a)}else c.texImage2D(e,0,r,h,u,l)}_compressedTexImage(e,t,r,s,o,n,l){const c=this._descriptor.context.gl;let _=null;const d=T(e),h=this._descriptor.isImmutable;if(d){if(this._descriptor.context.type!==a.zO.WEBGL2)throw new i.Z("3D textures are not supported in WebGL1");_=c}if(h){if(null!=l)if(d){if(null==n)throw new i.Z("Missing depth dimension for 3D texture upload");_.compressedTexSubImage3D(e,t,0,0,0,s,o,n,r,l)}else c.compressedTexSubImage2D(e,t,0,0,s,o,r,l)}else if(d){if(null==n)throw new i.Z("Missing depth dimension for 3D texture upload");_.compressedTexImage3D(e,t,r,s,o,n,0,l)}else c.compressedTexImage2D(e,t,r,s,o,0,l)}_forEachMipmapLevel(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1/0,{width:r,height:s,depth:o,hasMipmap:a,target:l}=this._descriptor;const c=l===n.No.TEXTURE_3D;if(null==r||null==s||c&&null==o)throw new i.Z("Missing texture dimensions for mipmap calculation");for(let i=0;e(i,r,s,o),a&&(1!==r||1!==s||c&&1!==o)&&!(i>=t);++i)r=Math.max(1,r>>1),s=Math.max(1,s>>1),c&&(o=Math.max(1,o>>1))}};function h(e,t){(null!=t.width&&t.width<0||null!=t.height&&t.height<0||null!=t.depth&&t.depth<0)&&console.error("Negative dimension parameters are not allowed!");const r=e.type===a.zO.WEBGL2;r||!t.isImmutable&&!T(t.target)||console.error("Immutable and 3D-like textures are not supported in WebGL1!"),r||null!=t.width&&(0,s.wt)(t.width)&&null!=t.height&&(0,s.wt)(t.height)||("number"==typeof t.wrapMode?t.wrapMode!==n.e8.CLAMP_TO_EDGE&&console.error("Non-power-of-two textures must have a wrap mode of CLAMP_TO_EDGE!"):t.wrapMode.s===n.e8.CLAMP_TO_EDGE&&t.wrapMode.t===n.e8.CLAMP_TO_EDGE||console.error("Non-power-of-two textures must have a wrap mode of CLAMP_TO_EDGE!"),t.hasMipmap&&console.error("Mipmapping requires power-of-two textures!"))}function u(e,t){let r=t.samplingMode,i=t.samplingMode;r===n.cw.LINEAR_MIPMAP_NEAREST||r===n.cw.LINEAR_MIPMAP_LINEAR?(r=n.cw.LINEAR,t.hasMipmap||(i=n.cw.LINEAR)):r!==n.cw.NEAREST_MIPMAP_NEAREST&&r!==n.cw.NEAREST_MIPMAP_LINEAR||(r=n.cw.NEAREST,t.hasMipmap||(i=n.cw.NEAREST)),e.texParameteri(t.target,e.TEXTURE_MAG_FILTER,r),e.texParameteri(t.target,e.TEXTURE_MIN_FILTER,i)}function p(e,t){"number"==typeof t.wrapMode?(e.texParameteri(t.target,e.TEXTURE_WRAP_S,t.wrapMode),e.texParameteri(t.target,e.TEXTURE_WRAP_T,t.wrapMode)):(e.texParameteri(t.target,e.TEXTURE_WRAP_S,t.wrapMode.s),e.texParameteri(t.target,e.TEXTURE_WRAP_T,t.wrapMode.t))}function m(e){return null!=e&&"type"in e&&"compressed"===e.type}function E(e){return null!=e&&!m(e)&&!function(e){return null!=e&&"byteLength"in e}(e)}function T(e){return e===n.No.TEXTURE_3D||e===n.No.TEXTURE_2D_ARRAY}function R(e,t,r){let i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,s=Math.max(t,r);return e===n.No.TEXTURE_3D&&(s=Math.max(s,i)),Math.round(Math.log(s)/Math.LN2)+1}d.TEXTURE_UNIT_FOR_UPDATES=0;const g=new Map},52311:(e,t,r)=>{r.d(t,{G:()=>a,X:()=>o});var i=r(8548),s=r(3384);class o{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e;this.width=e,this.height=t,this.target=i.No.TEXTURE_2D,this.pixelFormat=i.VI.RGBA,this.dataType=i.Br.UNSIGNED_BYTE,this.samplingMode=i.cw.LINEAR,this.wrapMode=i.e8.REPEAT,this.maxAnisotropy=1,this.flipped=!1,this.hasMipmap=!1,this.isOpaque=!1,this.unpackAlignment=4,this.preMultiplyAlpha=!1,this.depth=1,this.isImmutable=!1}}function a(e){return e.width<=0||e.height<=0?0:e.width*e.height*(e.hasMipmap?4/3:1)*(null==e.internalFormat?4:(0,s.RG)(e.internalFormat))}},3384:(e,t,r)=>{r.d(t,{HH:()=>s,RG:()=>n,UF:()=>a,XP:()=>o});r(93169);var i=r(8548);function s(e){const t=e.gl;switch(t.getError()){case t.NO_ERROR:return null;case t.INVALID_ENUM:return"An unacceptable value has been specified for an enumerated argument";case t.INVALID_VALUE:return"An unacceptable value has been specified for an argument";case t.INVALID_OPERATION:return"The specified command is not allowed for the current state";case t.INVALID_FRAMEBUFFER_OPERATION:return"The currently bound framebuffer is not framebuffer complete";case t.OUT_OF_MEMORY:return"Not enough memory is left to execute the command";case t.CONTEXT_LOST_WEBGL:return"WebGL context is lost"}return"Unknown error"}function o(e,t,r,i){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0;const o=e.gl;e.bindBuffer(r);for(const c of i){var a;const r=t.get(c.name);void 0===r&&console.error("There is no location for vertex attribute '".concat(c.name,"' defined."));const i=s*c.stride;if(c.count<=4)o.vertexAttribPointer(r,c.count,c.type,c.normalized,c.stride,c.offset+i),o.enableVertexAttribArray(r),c.divisor>0&&(null===(a=e.gl2)||void 0===a||a.vertexAttribDivisor(r,c.divisor));else if(9===c.count)for(let t=0;t<3;t++){var n;o.vertexAttribPointer(r+t,3,c.type,c.normalized,c.stride,c.offset+12*t+i),o.enableVertexAttribArray(r+t),c.divisor>0&&(null===(n=e.gl2)||void 0===n||n.vertexAttribDivisor(r+t,c.divisor))}else if(16===c.count)for(let t=0;t<4;t++){var l;o.vertexAttribPointer(r+t,4,c.type,c.normalized,c.stride,c.offset+16*t+i),o.enableVertexAttribArray(r+t),c.divisor>0&&(null===(l=e.gl2)||void 0===l||l.vertexAttribDivisor(r+t,c.divisor))}else console.error("Unsupported vertex attribute element count: "+c.count)}}function a(e,t,r,s){const o=e.gl;e.bindBuffer(r);for(const i of s){var a;const r=t.get(i.name);if(i.count<=4)o.disableVertexAttribArray(r),i.divisor&&i.divisor>0&&(null===(a=e.gl2)||void 0===a||a.vertexAttribDivisor(r,0));else if(9===i.count)for(let t=0;t<3;t++){var n;o.disableVertexAttribArray(r+t),i.divisor&&i.divisor>0&&(null===(n=e.gl2)||void 0===n||n.vertexAttribDivisor(r+t,0))}else if(16===i.count)for(let t=0;t<4;t++){var l;o.disableVertexAttribArray(r+t),i.divisor&&i.divisor>0&&(null===(l=e.gl2)||void 0===l||l.vertexAttribDivisor(r+t,0))}else console.error("Unsupported vertex attribute element count: "+i.count)}e.unbindBuffer(i.w0.ARRAY_BUFFER)}function n(e){switch(e){case i.VI.ALPHA:case i.VI.LUMINANCE:case i.VI.RED:case i.VI.RED_INTEGER:case i.lP.R8:case i.lP.R8I:case i.lP.R8UI:case i.lP.R8_SNORM:case i.Tg.STENCIL_INDEX8:return 1;case i.VI.LUMINANCE_ALPHA:case i.VI.RG:case i.VI.RG_INTEGER:case i.lP.RGBA4:case i.lP.R16F:case i.lP.R16I:case i.lP.R16UI:case i.lP.RG8:case i.lP.RG8I:case i.lP.RG8UI:case i.lP.RG8_SNORM:case i.lP.RGB565:case i.lP.RGB5_A1:case i.Tg.DEPTH_COMPONENT16:return 2;case i.VI.DEPTH_COMPONENT:case i.VI.RGB:case i.VI.RGB_INTEGER:case i.lP.RGB8:case i.lP.RGB8I:case i.lP.RGB8UI:case i.lP.RGB8_SNORM:case i.lP.SRGB8:case i.Tg.DEPTH_COMPONENT24:return 3;case i.VI.DEPTH_STENCIL:case i.VI.DEPTH24_STENCIL8:case i.VI.RGBA:case i.VI.RGBA_INTEGER:case i.lP.RGBA8:case i.lP.R32F:case i.lP.R11F_G11F_B10F:case i.lP.RG16F:case i.lP.R32I:case i.lP.R32UI:case i.lP.RG16I:case i.lP.RG16UI:case i.lP.RGBA8I:case i.lP.RGBA8UI:case i.lP.RGBA8_SNORM:case i.lP.SRGB8_ALPHA8:case i.lP.RGB9_E5:case i.lP.RGB10_A2UI:case i.lP.RGB10_A2:case i.Tg.DEPTH_STENCIL:case i.Tg.DEPTH_COMPONENT32F:case i.Tg.DEPTH24_STENCIL8:return 4;case i.Tg.DEPTH32F_STENCIL8:return 5;case i.lP.RGB16F:case i.lP.RGB16I:case i.lP.RGB16UI:return 6;case i.lP.RG32F:case i.lP.RG32I:case i.lP.RG32UI:case i.lP.RGBA16F:case i.lP.RGBA16I:case i.lP.RGBA16UI:return 8;case i.lP.RGB32F:case i.lP.RGB32I:case i.lP.RGB32UI:return 12;case i.lP.RGBA32F:case i.lP.RGBA32I:case i.lP.RGBA32UI:return 16;case i.q_.COMPRESSED_RGB_S3TC_DXT1_EXT:case i.q_.COMPRESSED_RGBA_S3TC_DXT1_EXT:return.5;case i.q_.COMPRESSED_RGBA_S3TC_DXT3_EXT:case i.q_.COMPRESSED_RGBA_S3TC_DXT5_EXT:return 1;case i.q_.COMPRESSED_R11_EAC:case i.q_.COMPRESSED_SIGNED_R11_EAC:case i.q_.COMPRESSED_RGB8_ETC2:case i.q_.COMPRESSED_SRGB8_ETC2:case i.q_.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case i.q_.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:return.5;case i.q_.COMPRESSED_RG11_EAC:case i.q_.COMPRESSED_SIGNED_RG11_EAC:case i.q_.COMPRESSED_RGBA8_ETC2_EAC:case i.q_.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return 1}return 0}},37825:(e,t,r)=>{r.d(t,{CG:()=>l,hZ:()=>n,zu:()=>c});var i=r(10064),s=r(93169);const o=r(32718).Z.getLogger("esri.views.webgl.checkWebGLError");const a=!!(0,s.Z)("enable-feature:webgl-debug");function n(){return a}function l(){return a}function c(e){if(n()){const t=e.getError();if(t){const r=function(e,t){switch(t){case e.INVALID_ENUM:return"Invalid Enum. An unacceptable value has been specified for an enumerated argument.";case e.INVALID_VALUE:return"Invalid Value. A numeric argument is out of range.";case e.INVALID_OPERATION:return"Invalid Operation. The specified command is not allowed for the current state.";case e.INVALID_FRAMEBUFFER_OPERATION:return"Invalid Framebuffer operation. The currently bound framebuffer is not framebuffer complete when trying to render to or to read from it.";case e.OUT_OF_MEMORY:return"Out of memory. Not enough memory is left to execute the command.";case e.CONTEXT_LOST_WEBGL:return"WebGL context has been lost";default:return"Unknown error"}}(e,t),s=(new Error).stack;o.error(new i.Z("webgl-error","WebGL error occurred",{message:r,stack:s}))}}}}}]);
//# sourceMappingURL=7808.37522930.chunk.js.map