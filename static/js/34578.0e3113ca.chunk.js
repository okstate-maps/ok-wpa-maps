"use strict";(self.webpackChunkok_wpa_maps=self.webpackChunkok_wpa_maps||[]).push([[34578],{1200:(t,s,e)=>{e.d(s,{fz:()=>y,g7:()=>P,zo:()=>p});var i=e(68707),n=e(91523),o=e(97799),h=e(63331),r=e(26871);const a=1.4142135623730951,m=.017453292519943295,f=256,c=1024;class _{static construct(t,s,e){const i=new _;return i.x=t.x,i.y=t.y,i.m_next=-1,i.m_prev=-1,i.z=s,i.m=e,i.type=0,i}clone(){const t=new _;return t.x=this.x,t.y=this.y,t.m_next=this.m_next,t.m_prev=this.m_prev,t.z=this.z,t.m=this.m,t.type=this.type,t}asPoint2D(){return new r.P(this.x,this.y)}}class l{constructor(t){this.m_distance=-1,this.m_tolerance=-1,this.m_miterLimit=10,this.m_joins=0,this.m_progressCounter=0,this.m_bUseZ=!1,this.m_bUseM=!1,this.m_srcPts=[],this.m_srcPtCount=0,this.m_offsetPts=[],this.m_offsetPtCount=0,this.m_a1=0,this.m_a2=0,this.m_progressTracker=t}constructOffset(){const t=this.m_inputGeometry.getGeometryType();if(t===o.G.enumLine)return this.offsetLine();if(t===o.G.enumEnvelope)return this.offsetEnvelope();if((0,o.f)(t)){const t=new h.P;return t.addSegment(this.m_inputGeometry,!0),this.m_inputGeometry=t,this.constructOffset()}if(t===o.G.enumPolyline){const t=new h.P;return this.offsetMultiPath(t),t}if(t===o.G.enumPolygon){const t=new h.a;return this.offsetMultiPath(t),t}(0,o.t)("")}offsetLine(){const t=this.m_inputGeometry,s=t.getStartXY(),e=t.getEndXY(),i=new r.P;i.setSub(e,s),i.normalize(),i.leftPerpendicularThis(),i.scale(this.m_distance),s.addThis(i),e.addThis(i);const n=t.clone();return n.setStartXY(s),n.setEndXY(e),n}offsetEnvelope(){const t=this.m_inputGeometry;if(this.m_distance>0&&2!==this.m_joins){const s=new h.a;return s.addEnvelope(t,!1),this.m_inputGeometry=s,this.constructOffset()}const s=t.clone();return s.inflateCoords(this.m_distance,this.m_distance),s}progress(){}static buildPoint(t,s,e,i){i.x=t.x+s*Math.cos(e),i.y=t.y+s*Math.sin(e),i.type=t.type,i.z=t.z,i.m=t.m,i.m_next=-1,i.m_prev=-1}addPoint(t){this.m_offsetPts.push(t.clone()),this.m_offsetPtCount++}addPointEx(t,s){if(0===this.m_offsetPtCount)return void this.addPoint(t);const e=this.m_srcPtCount,i=this.m_srcPts[0===s?e-1:s-1],n=this.m_srcPts[s],o=l.dotSign(i,n,this.m_offsetPts[this.m_offsetPtCount-1],t);if(o>0)this.addPoint(t);else if(o<0)if(l.dotSign(i,n,n,this.m_offsetPts[this.m_offsetPtCount-1])>0){const n=new _;let o;o=0===s?e-2:1===s?e-1:s-2;const h=this.m_srcPts[o],a=Math.atan2(i.y-h.y,i.x-h.x);if(l.buildPoint(i,this.m_distance,a-r.o,n),this.m_offsetPts[this.m_offsetPtCount-1]=n.clone(),1===this.m_joins||2===this.m_joins){n.x=.5*(n.x+i.x),n.y=.5*(n.y+i.y),this.addPoint(n),l.buildPoint(i,this.m_distance,this.m_a1+r.o,n);const t=n.clone();t.x=.5*(t.x+i.x),t.y=.5*(t.y+i.y),t.type|=f,this.addPoint(t),this.addPoint(n)}else l.buildPoint(i,this.m_distance,this.m_a1+r.o,n),n.type|=f,this.addPoint(n);this.addPointEx(t,s)}else{const t=new _;if(l.buildPoint(n,this.m_distance,this.m_a1+r.o,t),this.addPoint(t),1===this.m_joins||2===this.m_joins){t.x=.5*(t.x+n.x),t.y=.5*(t.y+n.y),this.addPoint(t),l.buildPoint(n,this.m_distance,this.m_a2-r.o,t);const s=t.clone();s.x=.5*(s.x+n.x),s.y=.5*(s.y+n.y),s.type|=f,this.addPoint(s),this.addPoint(t)}else l.buildPoint(n,this.m_distance,this.m_a2-r.o,t),t.type|=f,this.addPoint(t)}}buildOffset(){const t=new _,s=this.m_srcPtCount;this.m_offsetPtCount=0;const e=.5*this.m_tolerance;let i=0,n=0;for(let o=0;o<s;o++){const h=this.m_srcPts[o],_=0===o?this.m_srcPts[s-1]:this.m_srcPts[o-1],u=o===s-1?this.m_srcPts[0]:this.m_srcPts[o+1];let d,P,p=0;{const t=_.x-h.x,s=_.y-h.y,e=u.x-h.x,a=u.y-h.y;d=Math.atan2(s,t),P=Math.atan2(a,e),this.m_a1=d,this.m_a2=P,0===o&&(i=d,n=P),p=r.P.orientationRobust(h.asPoint2D(),_.asPoint2D(),u.asPoint2D())}const y=P;if(P<d&&(P+=r.p),!(Math.abs(Math.abs(d-P)-Math.PI)<1e-8))if(p*this.m_distance>0)if(1===this.m_joins||2===this.m_joins){l.buildPoint(h,this.m_distance,d+r.o,t),this.addPoint(t);const s=.001;t.x=h.x+(t.x-h.x)*s,t.y=h.y+(t.y-h.y)*s,this.addPoint(t),l.buildPoint(h,this.m_distance,P-r.o,t);const e=t.clone();e.x=h.x+(e.x-h.x)*s,e.y=h.y+(e.y-h.y)*s,e.type|=f,this.addPoint(e),this.addPoint(t)}else{const s=.5*(P-d),e=0===s?this.m_distance:this.m_distance/Math.abs(Math.sin(s));l.buildPoint(h,e,.5*(d+P),t),this.addPointEx(t,o)}else{if(512&h.type){const s=1-e/Math.abs(this.m_distance);let i=1,n=this.m_distance<0?-Math.PI:Math.PI;if(s>-1&&s<1){let t=2*Math.acos(s);t<m&&(t=m),i=Math.trunc(Math.PI/t+1.5),i>1&&(n/=i)}i<=1&&(i=2,n/=2);let a=d+r.o;l.buildPoint(h,this.m_distance,a,t),0===o&&(t.type|=c),this.addPointEx(t,o);const f=this.m_distance/Math.cos(n/2);for(a+=n/2,l.buildPoint(h,f,a,t),t.type|=c,this.addPoint(t);--i>0;)a+=n,l.buildPoint(h,f,a,t),t.type|=c,this.addPoint(t);l.buildPoint(h,this.m_distance,P-r.o,t),t.type|=c,this.addPoint(t);continue}if(1!==this.m_joins){if(0===this.m_joins){const s=1-e/Math.abs(this.m_distance);let i=1,n=P-r.o-(d+r.o);if(s>-1&&s<1){let t=2*Math.acos(s);t<m&&(t=m),i=Math.trunc(Math.abs(n)/t+1.5),i>1&&(n/=i)}const a=this.m_distance/Math.cos(.5*n);let f=d+r.o+.5*n;for(l.buildPoint(h,a,f,t),this.addPointEx(t,o);--i>0;)f+=n,l.buildPoint(h,a,f,t),this.addPoint(t);continue}if(2===this.m_joins){const s=_.x-h.x,e=_.y-h.y,i=u.x-h.x,n=u.y-h.y;let m=(s*i+e*n)/Math.sqrt(s*s+e*e)/Math.sqrt(i*i+n*n);if(m=Math.max(m,-1),m>1-1e-8){l.buildPoint(h,a*this.m_distance,P-.25*Math.PI,t),this.addPointEx(t,o),l.buildPoint(h,a*this.m_distance,P+.25*Math.PI,t),this.addPoint(t);continue}const f=Math.abs(this.m_distance/Math.sin(.5*Math.acos(m))),c=Math.abs(this.m_miterLimit*this.m_distance);if(f>c){const s=.5*(P-d),e=this.m_distance/Math.abs(Math.sin(s));l.buildPoint(h,e,.5*(d+P),t);const i=r.P.construct(t.x,t.y),n=r.P.construct(h.x,h.y),a=new r.P;a.setSub(i,n);const m=new r.P;m.setScaleAdd(c/a.length(),a,n);const _=Math.sqrt(f*f-this.m_distance*this.m_distance),u=(f-c)*Math.abs(this.m_distance)/_;this.m_distance>0?a.rightPerpendicularThis():a.leftPerpendicularThis(),a.scale(u/a.length());const p=new r.P;p.setAdd(m,a);const y=new r.P;y.setSub(m,a),t.x=p.x,t.y=p.y,this.addPointEx(t,o),t.x=y.x,t.y=y.y,this.addPoint(t);continue}const p=.5*(P-d),y=this.m_distance/Math.abs(Math.sin(p));l.buildPoint(h,y,.5*(d+P),t),this.addPointEx(t,o);continue}{let s;if(P=y,this.m_distance>0?(P>d&&(P-=r.p),s=d-P<r.o):(P<d&&(P+=r.p),s=P-d<r.o),s){const s=this.m_distance*a;let e;e=s<0?d+.25*Math.PI:d+3*Math.PI*.25,l.buildPoint(h,s,e,t),this.addPointEx(t,o),e=s<0?P-.25*Math.PI:P-3*Math.PI*.25,l.buildPoint(h,s,e,t),this.addPoint(t)}else{const s=.5*(P-d),e=this.m_distance/Math.abs(Math.sin(s));P<d&&(P+=r.p),l.buildPoint(h,e,(d+P)/2,t),this.addPointEx(t,o)}}}else l.buildPoint(h,this.m_distance,d+r.o,t),this.addPointEx(t,o),l.buildPoint(h,this.m_distance,P-r.o,t),this.addPoint(t)}}return this.m_a1=i,this.m_a2=n,this.addPointEx(this.m_offsetPts[0],0),this.m_offsetPts[0]=this.m_offsetPts[this.m_offsetPtCount-1].clone(),this.removeBadSegsFast()}removeBadSegsFast(){let t=!1;for(let e=0;e<this.m_offsetPtCount;e++){const t=this.m_offsetPts[e];t.m_next=e+1,t.m_prev=e-1}this.m_offsetPts[0].m_prev=this.m_offsetPtCount-2,this.m_offsetPts[this.m_offsetPtCount-2].m_next=0;let s=0;for(let e=0;e<this.m_offsetPtCount;e++)if(this.m_offsetPts[s].type&f){const e=this.deleteClosedSeg(s);if(-1===e){t=!0;break}s=e}else s=this.m_offsetPts[s].m_next;return!t&&(this.compressOffsetArray(s),!0)}deleteClosedSeg(t){const s=this.m_offsetPtCount-1;let e,i,n=t;for(let o=1;o<=s-2;o++){n=this.m_offsetPts[n].m_next,e=n,i=t;for(let t=1;t<=o;t++){if(i=this.m_offsetPts[i].m_prev,0===(this.m_offsetPts[i].type&f)&&0===(this.m_offsetPts[e].type&f)){const t=this.handleClosedIntersection(i,e);if(-1!==t)return t}e=this.m_offsetPts[e].m_prev}}return-1}handleClosedIntersection(t,s){const e=this.m_offsetPts[this.m_offsetPts[t].m_prev],i=this.m_offsetPts[t],n=this.m_offsetPts[this.m_offsetPts[s].m_prev],o=this.m_offsetPts[s];if(!this.sectGraphicRect(e,i,n,o))return-1;const h={pt:new _,bAtExistingPt:!1};if(((i.x-e.x)*(o.y-n.y)-(i.y-e.y)*(o.x-n.x))*this.m_distance<0&&this.findIntersection(e,i,n,o,h)&&!h.bAtExistingPt){const r=1e-8,a=Math.sqrt((i.x-e.x)*(i.x-e.x)+(i.y-e.y)*(i.y-e.y)),m=(i.x-e.x)/a,f=(i.y-e.y)/a,c=Math.sqrt((o.x-n.x)*(o.x-n.x)+(o.y-n.y)*(o.y-n.y)),_=(o.x-n.x)/c,l=(o.y-n.y)/c;let u=!1;const d=h.pt.clone();d.x+=(m+_)*r,d.y+=(f+l)*r;let P=n,p=h.pt,y=this.m_offsetPts[t].m_prev;for(;p.y>d.y!=P.y>d.y&&d.x<(P.x-p.x)*(d.y-p.y)/(P.y-p.y)+p.x&&(u=!u),P=p,y=this.m_offsetPts[y].m_next,y!==s;)p=this.m_offsetPts[y];if(u)return-1;const x=this.m_offsetPts[t].m_prev;return h.pt.type=i.type,h.pt.m_next=s,h.pt.m_prev=x,this.m_offsetPts[t]=h.pt,this.m_offsetPts[s].m_prev=t,s}return-1}sectGraphicRect(t,s,e,i){return Math.max(t.x,s.x)>=Math.min(e.x,i.x)&&Math.max(e.x,i.x)>=Math.min(t.x,s.x)&&Math.max(t.y,s.y)>=Math.min(e.y,i.y)&&Math.max(e.y,i.y)>=Math.min(t.y,s.y)}findIntersection(t,s,e,i,n){let o,h,r,a;return n.bAtExistingPt=!1,o=(s.y-t.y)*(i.x-e.x)-(s.x-t.x)*(i.y-e.y),h=(e.y-t.y)*(s.x-t.x)-(e.x-t.x)*(s.y-t.y),r=0===o?2:h/o,r>=0&&r<=1&&(a=r,o=(i.y-e.y)*(s.x-t.x)-(i.x-e.x)*(s.y-t.y),h=(t.y-e.y)*(i.x-e.x)-(t.x-e.x)*(i.y-e.y),r=0===o?2:h/o,r>=0&&r<=1)&&(n.pt.x=t.x+r*(s.x-t.x),n.pt.y=t.y+r*(s.y-t.y),this.m_bUseZ&&(n.pt.z=e.z+a*(i.z-e.z)),this.m_bUseM&&(n.pt.m=e.m+a*(i.m-e.m)),0!==a&&1!==a||0!==r&&1!==r||(n.bAtExistingPt=!0),!((0===a||1===a)&&r>0&&r<1||(0===r||1===r)&&a>0&&a<1))}compressOffsetArray(t){for(;this.m_offsetPts[t].m_prev<t;)t=this.m_offsetPts[t].m_prev;let s=0,e=t;do{const t=this.m_offsetPts[e].clone();this.m_offsetPts[s]=t,e=t.m_next,s++}while(e!==t);this.m_offsetPts[s]=this.m_offsetPts[0].clone(),this.m_offsetPtCount=s+1}addPart(t,s){if(!(s<2))for(let e=0;e<s;e++){const s=this.m_offsetPts[t+e];if(e?this.m_bUseZ?this.m_resultPath.lineTo3DCoords(s.x,s.y,s.z):this.m_resultPath.lineToCoords(s.x,s.y):this.m_bUseZ?this.m_resultPath.startPath3DCoords(s.x,s.y,s.z):this.m_resultPath.startPathCoords(s.x,s.y),this.m_bUseM){const t=this.m_resultPath.getPointCount()-1;this.m_resultPath.setAttribute(2,t,0,s.m)}}}offsetMultiPath(t){const s=(0,h.d)(this.m_inputGeometry,0,this.m_tolerance,0,this.m_progressTracker,12e3),e=s.querySegmentIterator();e.resetToFirstPath();let i=-1;for(;e.nextPath();)i++,this.offsetPath(s,i,t)}offsetPath(t,s,e){let i=t.getPathStart(s),n=t.getPathEnd(s);if(this.m_resultPath=e,t.isClosedPath(s)){const s=t.getXY(i);for(;n>i&&t.getXY(n-1).equals(s);)n--;if(n-i>=2){this.m_srcPtCount=n-i,this.m_srcPts.length=this.m_srcPtCount;for(let s=i;s<n;s++)this.progress(),this.m_srcPts[s-i]=_.construct(t.getXY(s),this.m_bUseZ?t.getAttributeAsDbl(1,s,0):0,this.m_bUseM?t.getAttributeAsDbl(2,s,0):0);this.buildOffset()&&this.addPart(0,this.m_offsetPtCount-1)}}else{const s=t.getXY(i);for(;i<n-1&&t.getXY(i+1).equals(s);)i++;const e=t.getXY(n-1);for(;i<n-1&&t.getXY(n-2).equals(e);)n--;if(n-i>=2){this.m_srcPtCount=2*(n-i)-2,this.m_srcPts.length=this.m_srcPtCount;let e=_.construct(s,this.m_bUseZ?t.getAttributeAsDbl(1,i,0):0,this.m_bUseM?t.getAttributeAsDbl(2,i,0):0);e.type|=1536,this.m_srcPts[0]=e;let o=1,h=this.m_srcPtCount-1;for(let s=i+1;s<n-1;s++,o++,h--)this.progress(),e=_.construct(t.getXY(s),this.m_bUseZ?t.getAttributeAsDbl(1,s,0):0,this.m_bUseM?t.getAttributeAsDbl(2,s,0):0),this.m_srcPts[o]=e.clone(),e.type|=c,this.m_srcPts[h]=e.clone();if(e=_.construct(t.getXY(n-1),this.m_bUseZ?t.getAttributeAsDbl(1,n-1,0):0,this.m_bUseM?t.getAttributeAsDbl(2,n-1,0):0),e.type|=512,this.m_srcPts[o]=e.clone(),this.buildOffset())if(this.m_offsetPts.length>=2){let t=-1,s=-1,e=0!==(this.m_offsetPts[this.m_offsetPtCount-1].type&c);e||(t=0);for(let i=1;i<this.m_offsetPtCount;i++){this.progress();const n=0!==(this.m_offsetPts[i].type&c);n?e||(s=i-1,s-t+1>1&&this.addPart(t,s-t+1)):e&&(t=i-1),e=n}e||(s=this.m_offsetPtCount-1,s-t+1>1&&this.addPart(t,s-t+1))}else{const t=0,s=this.m_offsetPtCount-1;s-t>=1&&this.addPart(t,s-t+1)}}}this.m_srcPts.length=0,this.m_srcPtCount=0,this.m_offsetPts.length=0,this.m_offsetPtCount=0}static dotSign(t,s,e,i){const n=s.x-t.x,o=s.y-t.y,h=i.x-e.x,a=i.y-e.y,m=(0,r.t)(n,o,h,a);return(0,r.e)(m)}}class u extends i.G{constructor(t,s,e,i,n,o,h){super(),this.m_progressTracker=h,this.m_index=-1,this.m_inputGeoms=t,this.m_spatialReference=s,this.m_distance=e,this.m_joins=i,this.m_miterLimit=n,this.m_flattenError=o}tock(){return!0}getRank(){return 1}next(){if(!this.m_inputGeoms)return null;let t;for(;t=this.m_inputGeoms.next();)return this.m_index=this.m_inputGeoms.getGeometryID(),this.offset(t);return null}getGeometryID(){return this.m_index}offset(t){let s;return(0,o.c)(t),s=this.m_flattenError<=0?(0,n.b)(this.m_spatialReference,t,!0).total():this.m_flattenError,function(t,s,e,i,n,h){if(null===t&&(0,o.a)(""),t.getDimension()<1&&(0,o.a)(""),n>0||(0,o.a)(""),(0,o.c)(t),0===s||t.isEmpty())return t;const r=new l(h);return r.m_bUseZ=t.hasAttribute(1),r.m_bUseM=t.hasAttribute(2),r.m_inputGeometry=t,r.m_distance=s,r.m_tolerance=n,r.m_joins=e,r.m_miterLimit=i>1?i:1,r.m_progressCounter=0,r.constructOffset()}(t,this.m_distance,this.m_joins,this.m_miterLimit,s,this.m_progressTracker)}}const d=new class{getOperatorType(){return 10108}accelerateGeometry(t,s,e){return!1}canAccelerateGeometry(t){return!1}supportsCurves(){return!0}executeMany(t,s,e,i,n,o,h){return new u(t,s,e,i,n,o,h)}execute(t,s,e,i,n,o,h){return new u(null,s,e,i,n,o,h).offset(t)}};function P(t,s,e,i,n,o){return d.execute(t,s,e,i,n,o,null)}function p(t,s,e,n,o,h){const r=d.executeMany(new i.S(t),s,e,n,o,h,null);return Array.from(r)}function y(){return d.supportsCurves()}},34578:(t,s,e)=>{e.d(s,{tr:()=>u,cY:()=>d,LT:()=>p});var i=e(21508),n=e(83395),o=e(11217),h=e(52847),r=e(81130),a=e(31633),m=e(1200),f=e(58067);const c={round:0,bevel:1,miter:2,square:3};(0,m.fz)();var _=e(5262),l=e(19902);function u(t){let{templatePart:s,edits:e,relationships:a,shape:m,distance:f,isProportional:c,offsetDistance:u,vertexBeforeOffset:P,vertexPlacement:p,mode:y}=t;const x=P||0===u?m:d(m,u);if(null===x||!(0,l.Rg)(x))return;const g=(0,i.TR)(x.spatialReference);u=P?u:0;let b=0,M=null,C=0;for(let i=0;i<x.paths.length;i++){if(e.length>r.Cg&&"digitizing"===y)return;const t=x.paths[i].length,m=i===x.paths.length-1;for(let l=0;l<t;l++){if(e.length>r.Cg&&"digitizing"===y)return;if(l>0&&0!==f&&(b+=x.hasZ?(0,n.BM)(x.paths[i][l-1],x.paths[i][l],g):(0,_.R3)(x.paths[i][l-1],x.paths[i][l])),(0!==l||1!==p)&&!(l===t-1&&2===p&&m||(0===l||l===t-1&&m)&&3===p||0===l&&f<0&&c||l===t-1&&f>0&&c)){if(0!==f){let s=1;if(c){const e=f<0?l-1:l+1;if(e>=t||e<0)continue;s=x.hasZ?(0,n.BM)(x.paths[i][l],x.paths[i][e],g):(0,_.R3)(x.paths[i][l],x.paths[i][e])}const e=b+s*f;M=x.hasZ?(0,h.mw)(x,e,u,g):(0,h.a1)(x,e,0)}else M=(0,h.RT)(x,i,l),0!==u&&(M=(0,h.LB)(M,l===t-1?[x.paths[i][l-1],x.paths[i][l]]:[x.paths[i][l],x.paths[i][l+1]],u));M&&(0,o.fS)({templatePart:s,shape:M,edits:e,relationships:a,mode:y},"V".concat((C+l).toString()))}}C+=t}}function d(t,s){return function(t,s){let e=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const{miterLimit:i=10,flattenError:n=0,joins:o="round",unit:h}=e,r=(0,f.getSpatialReference)(t);return h&&(s=(0,a.UW)(s,h,r)),(0,f.toGeometry)((0,m.g7)((0,f.fromGeometry)(t),(0,f.fromSpatialReference)(r),s,c[o],i,n),r)}(t,s,{unit:"meters",joins:"miter",miterLimit:2})}function P(t){let s=0;for(const e of t.paths)s+=e.length;return s}function p(t){let{templatePart:s,edits:e,relationships:r,shape:a,distance:m,isProportional:f,offsetDistance:c,vertexBeforeOffset:u,vertexPlacement:p,mode:y}=t;const x=u||0===c?a:d(a,c);if(null===x||!(0,l.Rg)(x))return;const g=(0,i.TR)(x.spatialReference);c=u?c:0;let b=null,M="";if(0!==m){const t=4===p?0:x.paths.length-1,s=4===p?0:x.paths[x.paths.length-1].length-1,e=4===p?0:(0,h.Ex)(x),i=4===p?x.paths[0].length:x.paths[x.paths.length-1].length;let o=1;if(f){const e=m<0?s-1:s+1;if(e>=i||e<0)return;o=x.hasZ?(0,n.BM)(x.paths[t][s],x.paths[t][e],g):(0,_.R3)(x.paths[t][s],x.paths[t][e])}const r=e+o*m;b=x.hasZ?(0,h.mw)(x,r,c,g):(0,h.a1)(x,r,c),M=4===p?"V0":"V".concat((P(x)-1).toString())}else{if(b=4===p?(0,h.RT)(x,0,0):(0,h.RT)(x,x.paths.length-1,x.paths[x.paths.length-1].length-1),0!==c)if(4===p)b=(0,h.LB)(b,[x.paths[0][0],x.paths[0][1]],c);else{const t=x.paths[x.paths.length-1];b=(0,h.LB)(b,[t[t.length-2],t[t.length-1]],c)}M=4===p?"V0":"V".concat((P(x)-1).toString())}b&&(0,o.fS)({templatePart:s,shape:b,edits:e,relationships:r,mode:y},M)}}}]);
//# sourceMappingURL=34578.0e3113ca.chunk.js.map