{"version":3,"file":"static/js/58755.7ec8f686.chunk.js","mappings":"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","sources":["../node_modules/timezone-groups/dist/utils/time-zones.mjs","../node_modules/timezone-groups/dist/groupByOffset/index.mjs","../node_modules/timezone-groups/dist/utils/region.mjs"],"sourcesContent":["import { b as getAllTimezones, a as getTimezone } from '../chunks/index-p4VH55K1.mjs';\n\n/**\n * Handling these deprecated timezones locally until `countries-and-timezones` is updated with the latest IANA time zone db\n *\n * @see https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\n * @see https://github.com/eggert/tz/commit/782d082623aaa130178d944bdbfbb563d2e1adfa\n * @see https://github.com/eggert/tz/commit/a0b09c0230089252acf2eb0f1ba922e99f7f4a03\n */\nconst deprecatedTimeZonesToAlias = {\n    /* eslint-disable @typescript-eslint/naming-convention */\n    CET: 'Europe/Brussels',\n    CST6CDT: 'America/Chicago',\n    EET: 'Europe/Athens',\n    EST: 'America/Panama',\n    EST5EDT: 'America/New_York',\n    HST: 'Pacific/Honolulu',\n    MET: 'Europe/Brussels',\n    MST: 'America/Phoenix',\n    MST7MDT: 'America/Denver',\n    PST8PDT: 'America/Los_Angeles',\n    WET: 'Europe/Lisbon',\n    /* eslint-enable @typescript-eslint/naming-convention */\n};\n/**\n * List of all supported, canonical, timezones.\n */\nconst timeZones = (() => {\n    const futureDeprecatedTimeZones = Object.keys(deprecatedTimeZonesToAlias);\n    return Object.keys(getAllTimezones()).filter((tz) => !futureDeprecatedTimeZones.includes(tz));\n})();\n/**\n * Normalize an IANA timezone name to its canonical equivalent.\n */\nfunction normalize(tz) {\n    const localDeprecatedTimeZone = deprecatedTimeZonesToAlias[tz];\n    if (localDeprecatedTimeZone) {\n        return localDeprecatedTimeZone;\n    }\n    const tzData = getTimezone(tz);\n    return tzData?.aliasOf ?? tz;\n}\n\nexport { normalize, timeZones };\n","import { timeZones } from '../utils/time-zones.mjs';\nimport { extractRegion, global } from '../utils/region.mjs';\nimport '../chunks/index-p4VH55K1.mjs';\n\nconst now = new Date();\nconst startDate = now.toISOString();\nconst daysInYear = 365;\nconst groupDateRange = daysInYear;\nconst defaultGroupingOptions = {\n    groupDateRange,\n    startDate,\n};\n\nconst _getDates = (startDate, numberDays, dateEngine) => {\n    const dateArray = [];\n    let date = dateEngine.create(startDate);\n    for (let i = 0; i <= numberDays; i++) {\n        date = dateEngine.increase(date);\n        dateArray.push(dateEngine.formatToIsoDateString(date));\n    }\n    return dateArray;\n};\nconst generateTimeZoneMetadata = (timeZoneItems, startDate, numberDays, dateEngine) => {\n    const processedDates = new Map();\n    const theDates = _getDates(startDate, numberDays, dateEngine);\n    return timeZoneItems.map((tzItem) => {\n        const { label } = tzItem;\n        const continent = extractRegion(label);\n        const dates = theDates.map((date) => {\n            const key = `${date}-${label}`;\n            let utc = processedDates.get(key);\n            if (utc) {\n                return utc;\n            }\n            utc = dateEngine.isoToTimeZone(date, label);\n            processedDates.set(key, utc);\n            return utc;\n        });\n        return {\n            ...tzItem,\n            continent,\n            isRegularContinent: continent !== global,\n            dates,\n        };\n    });\n};\nconst compareDateArrs = (array1, array2, dateEngine) => array1.length === array2.length &&\n    array1.every((value, index) => dateEngine.same(value, array2[index]));\nconst getGroupLabelTimeZoneIndices = (rawTZs, max = 5) => {\n    const shrinkedTzs = rawTZs.filter(({ label }) => extractRegion(label) !== global);\n    if (shrinkedTzs.length === 0) {\n        return [0];\n    }\n    const validLabels = shrinkedTzs.map((tz) => rawTZs.indexOf(tz));\n    return equallyDistributedSampling(validLabels, max);\n};\nfunction equallyDistributedSampling(items, maxItems = 5) {\n    const totalItems = items.length;\n    if (totalItems <= maxItems) {\n        return items;\n    }\n    const numberItemsToSelect = Math.min(totalItems - 2, maxItems - 2);\n    const stepSize = (totalItems - 1) / (numberItemsToSelect + 1);\n    return [\n        items[0],\n        ...Array.from({ length: numberItemsToSelect }, (_, i) => items[Math.round((i + 1) * stepSize)]),\n        items[totalItems - 1],\n    ];\n}\n\nasync function groupByOffset(options) {\n    const { groupDateRange, startDate, dateEngine } = {\n        ...defaultGroupingOptions,\n        ...options,\n    };\n    const grouping = [];\n    if (!dateEngine) {\n        throw new Error('dateEngine is required');\n    }\n    const timeZoneItems = timeZones.map((tz) => ({ label: tz }));\n    const timeZoneMetadata = generateTimeZoneMetadata(timeZoneItems, startDate, groupDateRange, dateEngine);\n    // We traverse the mappedDB and see if we find matches by comparing each set\n    // of transformed date for that specific TZ.\n    for (const tzMetadatumI of timeZoneMetadata) {\n        const { label, continent, dates } = tzMetadatumI;\n        if (tzMetadatumI.visited) {\n            continue;\n        }\n        tzMetadatumI.visited = true;\n        const newGroup = {\n            labelIdx: [],\n            tzs: [{ label }],\n        };\n        for (const tzMetadatumJ of timeZoneMetadata.filter((_) => !_.visited)) {\n            const { label: labelJ, continent: continentJ, isRegularContinent: isRegularContinentJ, dates: datesJ, } = tzMetadatumJ;\n            // We define a matching TZ by:\n            // 1) if both continents match (avoid grouping Antarctica with anything else)\n            // 2) if the transformed dates match in both TZs\n            if ((continent === continentJ || !isRegularContinentJ) &&\n                compareDateArrs(dates, datesJ, dateEngine)) {\n                const tzItem = { label: labelJ };\n                newGroup.tzs.push(tzItem);\n                tzMetadatumJ.visited = true;\n            }\n        }\n        grouping.push(newGroup);\n    }\n    // Now that we have a group, we want an easy way to find a fitting label for the group\n    // which is defined as the list of the most-common 7 cities, shown in alphabetical order\n    return grouping\n        .map((group) => {\n        group.tzs = group.tzs.sort((a, b) => a.label.localeCompare(b.label));\n        return {\n            labelTzIdx: getGroupLabelTimeZoneIndices(group.tzs, 7),\n            tzs: group.tzs.map((_) => _.label),\n        };\n    })\n        .sort((a, b) => b.tzs.length - a.tzs.length);\n}\n\nexport { groupByOffset };\n","import { g as getCountryForTimezone, a as getTimezone } from '../chunks/index-p4VH55K1.mjs';\n\nconst global = 'Global';\n/**\n * Check if a timezone is global (no country associated).\n */\nfunction isGlobal(tz) {\n    return getTimezone(tz).countries.length === 0;\n}\n/**\n * Extract the region from a timezone.\n */\nfunction extractRegion(tz) {\n    if (isGlobal(tz)) {\n        return global;\n    }\n    const separatorIndex = tz.indexOf('/');\n    return separatorIndex === -1 ? tz : tz.slice(0, separatorIndex);\n}\n/**\n * Gets the country code for a timezone.\n */\nfunction getCountry(timeZone) {\n    return getCountryForTimezone(timeZone)?.id ?? timeZone;\n}\n\nexport { extractRegion, getCountry, global };\n"],"names":["deprecatedTimeZonesToAlias","CET","CST6CDT","EET","EST","EST5EDT","HST","MET","MST","MST7MDT","PST8PDT","WET","timeZones","futureDeprecatedTimeZones","Object","keys","getAllTimezones","filter","tz","includes","normalize","_tzData$aliasOf","localDeprecatedTimeZone","tzData","getTimezone","aliasOf","defaultGroupingOptions","groupDateRange","startDate","Date","toISOString","generateTimeZoneMetadata","timeZoneItems","numberDays","dateEngine","processedDates","Map","theDates","_getDates","dateArray","date","create","i","increase","push","formatToIsoDateString","map","tzItem","label","continent","extractRegion","dates","key","concat","utc","get","isoToTimeZone","set","_objectSpread","isRegularContinent","global","compareDateArrs","array1","array2","length","every","value","index","same","getGroupLabelTimeZoneIndices","rawTZs","max","arguments","undefined","shrinkedTzs","_ref","items","maxItems","totalItems","numberItemsToSelect","Math","min","stepSize","Array","from","_","round","equallyDistributedSampling","indexOf","async","groupByOffset","options","grouping","Error","timeZoneMetadata","tzMetadatumI","visited","newGroup","labelIdx","tzs","tzMetadatumJ","labelJ","continentJ","isRegularContinentJ","datesJ","group","sort","a","b","localeCompare","labelTzIdx","countries","isGlobal","separatorIndex","slice","getCountry","timeZone","_getCountryForTimezon","_getCountryForTimezon2","getCountryForTimezone","id"],"sourceRoot":""}